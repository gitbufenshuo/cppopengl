// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mc/comm/gltf.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mc_2fcomm_2fgltf_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mc_2fcomm_2fgltf_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mc_2fcomm_2fgltf_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mc_2fcomm_2fgltf_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mc_2fcomm_2fgltf_2eproto;
namespace mc {
namespace comm {
class Accessor;
struct AccessorDefaultTypeInternal;
extern AccessorDefaultTypeInternal _Accessor_default_instance_;
class Asset;
struct AssetDefaultTypeInternal;
extern AssetDefaultTypeInternal _Asset_default_instance_;
class Attributes;
struct AttributesDefaultTypeInternal;
extern AttributesDefaultTypeInternal _Attributes_default_instance_;
class Buffer;
struct BufferDefaultTypeInternal;
extern BufferDefaultTypeInternal _Buffer_default_instance_;
class BufferView;
struct BufferViewDefaultTypeInternal;
extern BufferViewDefaultTypeInternal _BufferView_default_instance_;
class GLTF;
struct GLTFDefaultTypeInternal;
extern GLTFDefaultTypeInternal _GLTF_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class Mesh;
struct MeshDefaultTypeInternal;
extern MeshDefaultTypeInternal _Mesh_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Primitive;
struct PrimitiveDefaultTypeInternal;
extern PrimitiveDefaultTypeInternal _Primitive_default_instance_;
class Sampler;
struct SamplerDefaultTypeInternal;
extern SamplerDefaultTypeInternal _Sampler_default_instance_;
class Scene;
struct SceneDefaultTypeInternal;
extern SceneDefaultTypeInternal _Scene_default_instance_;
class Texture;
struct TextureDefaultTypeInternal;
extern TextureDefaultTypeInternal _Texture_default_instance_;
}  // namespace comm
}  // namespace mc
PROTOBUF_NAMESPACE_OPEN
template<> ::mc::comm::Accessor* Arena::CreateMaybeMessage<::mc::comm::Accessor>(Arena*);
template<> ::mc::comm::Asset* Arena::CreateMaybeMessage<::mc::comm::Asset>(Arena*);
template<> ::mc::comm::Attributes* Arena::CreateMaybeMessage<::mc::comm::Attributes>(Arena*);
template<> ::mc::comm::Buffer* Arena::CreateMaybeMessage<::mc::comm::Buffer>(Arena*);
template<> ::mc::comm::BufferView* Arena::CreateMaybeMessage<::mc::comm::BufferView>(Arena*);
template<> ::mc::comm::GLTF* Arena::CreateMaybeMessage<::mc::comm::GLTF>(Arena*);
template<> ::mc::comm::Image* Arena::CreateMaybeMessage<::mc::comm::Image>(Arena*);
template<> ::mc::comm::Mesh* Arena::CreateMaybeMessage<::mc::comm::Mesh>(Arena*);
template<> ::mc::comm::Node* Arena::CreateMaybeMessage<::mc::comm::Node>(Arena*);
template<> ::mc::comm::Primitive* Arena::CreateMaybeMessage<::mc::comm::Primitive>(Arena*);
template<> ::mc::comm::Sampler* Arena::CreateMaybeMessage<::mc::comm::Sampler>(Arena*);
template<> ::mc::comm::Scene* Arena::CreateMaybeMessage<::mc::comm::Scene>(Arena*);
template<> ::mc::comm::Texture* Arena::CreateMaybeMessage<::mc::comm::Texture>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mc {
namespace comm {

// ===================================================================

class Scene final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mc.comm.Scene) */ {
 public:
  inline Scene() : Scene(nullptr) {}
  ~Scene() override;
  explicit PROTOBUF_CONSTEXPR Scene(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Scene(const Scene& from);
  Scene(Scene&& from) noexcept
    : Scene() {
    *this = ::std::move(from);
  }

  inline Scene& operator=(const Scene& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scene& operator=(Scene&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Scene& default_instance() {
    return *internal_default_instance();
  }
  static inline const Scene* internal_default_instance() {
    return reinterpret_cast<const Scene*>(
               &_Scene_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Scene& a, Scene& b) {
    a.Swap(&b);
  }
  inline void Swap(Scene* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Scene* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Scene* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Scene>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Scene& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Scene& from) {
    Scene::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scene* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mc.comm.Scene";
  }
  protected:
  explicit Scene(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated int32 nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  private:
  int32_t _internal_nodes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_nodes() const;
  void _internal_add_nodes(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_nodes();
  public:
  int32_t nodes(int index) const;
  void set_nodes(int index, int32_t value);
  void add_nodes(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      nodes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:mc.comm.Scene)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > nodes_;
    mutable std::atomic<int> _nodes_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mc_2fcomm_2fgltf_2eproto;
};
// -------------------------------------------------------------------

class Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mc.comm.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  explicit PROTOBUF_CONSTEXPR Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Node& from) {
    Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mc.comm.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMeshFieldNumber = 1,
  };
  // int32 mesh = 1;
  void clear_mesh();
  int32_t mesh() const;
  void set_mesh(int32_t value);
  private:
  int32_t _internal_mesh() const;
  void _internal_set_mesh(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mc.comm.Node)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t mesh_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mc_2fcomm_2fgltf_2eproto;
};
// -------------------------------------------------------------------

class Attributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mc.comm.Attributes) */ {
 public:
  inline Attributes() : Attributes(nullptr) {}
  ~Attributes() override;
  explicit PROTOBUF_CONSTEXPR Attributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Attributes(const Attributes& from);
  Attributes(Attributes&& from) noexcept
    : Attributes() {
    *this = ::std::move(from);
  }

  inline Attributes& operator=(const Attributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attributes& operator=(Attributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Attributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attributes* internal_default_instance() {
    return reinterpret_cast<const Attributes*>(
               &_Attributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Attributes& a, Attributes& b) {
    a.Swap(&b);
  }
  inline void Swap(Attributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Attributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Attributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Attributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Attributes& from) {
    Attributes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mc.comm.Attributes";
  }
  protected:
  explicit Attributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPOSITIONFieldNumber = 1,
    kNORMALFieldNumber = 2,
    kTEXCOORD0FieldNumber = 3,
  };
  // int32 POSITION = 1;
  void clear_position();
  int32_t position() const;
  void set_position(int32_t value);
  private:
  int32_t _internal_position() const;
  void _internal_set_position(int32_t value);
  public:

  // int32 NORMAL = 2;
  void clear_normal();
  int32_t normal() const;
  void set_normal(int32_t value);
  private:
  int32_t _internal_normal() const;
  void _internal_set_normal(int32_t value);
  public:

  // int32 TEXCOORD_0 = 3;
  void clear_texcoord_0();
  int32_t texcoord_0() const;
  void set_texcoord_0(int32_t value);
  private:
  int32_t _internal_texcoord_0() const;
  void _internal_set_texcoord_0(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mc.comm.Attributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t position_;
    int32_t normal_;
    int32_t texcoord_0_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mc_2fcomm_2fgltf_2eproto;
};
// -------------------------------------------------------------------

class Primitive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mc.comm.Primitive) */ {
 public:
  inline Primitive() : Primitive(nullptr) {}
  ~Primitive() override;
  explicit PROTOBUF_CONSTEXPR Primitive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Primitive(const Primitive& from);
  Primitive(Primitive&& from) noexcept
    : Primitive() {
    *this = ::std::move(from);
  }

  inline Primitive& operator=(const Primitive& from) {
    CopyFrom(from);
    return *this;
  }
  inline Primitive& operator=(Primitive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Primitive& default_instance() {
    return *internal_default_instance();
  }
  static inline const Primitive* internal_default_instance() {
    return reinterpret_cast<const Primitive*>(
               &_Primitive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Primitive& a, Primitive& b) {
    a.Swap(&b);
  }
  inline void Swap(Primitive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Primitive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Primitive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Primitive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Primitive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Primitive& from) {
    Primitive::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Primitive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mc.comm.Primitive";
  }
  protected:
  explicit Primitive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kIndicesFieldNumber = 1,
  };
  // .mc.comm.Attributes attributes = 2;
  bool has_attributes() const;
  private:
  bool _internal_has_attributes() const;
  public:
  void clear_attributes();
  const ::mc::comm::Attributes& attributes() const;
  PROTOBUF_NODISCARD ::mc::comm::Attributes* release_attributes();
  ::mc::comm::Attributes* mutable_attributes();
  void set_allocated_attributes(::mc::comm::Attributes* attributes);
  private:
  const ::mc::comm::Attributes& _internal_attributes() const;
  ::mc::comm::Attributes* _internal_mutable_attributes();
  public:
  void unsafe_arena_set_allocated_attributes(
      ::mc::comm::Attributes* attributes);
  ::mc::comm::Attributes* unsafe_arena_release_attributes();

  // int32 indices = 1;
  void clear_indices();
  int32_t indices() const;
  void set_indices(int32_t value);
  private:
  int32_t _internal_indices() const;
  void _internal_set_indices(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mc.comm.Primitive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::mc::comm::Attributes* attributes_;
    int32_t indices_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mc_2fcomm_2fgltf_2eproto;
};
// -------------------------------------------------------------------

class Mesh final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mc.comm.Mesh) */ {
 public:
  inline Mesh() : Mesh(nullptr) {}
  ~Mesh() override;
  explicit PROTOBUF_CONSTEXPR Mesh(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mesh(const Mesh& from);
  Mesh(Mesh&& from) noexcept
    : Mesh() {
    *this = ::std::move(from);
  }

  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mesh& operator=(Mesh&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mesh& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mesh* internal_default_instance() {
    return reinterpret_cast<const Mesh*>(
               &_Mesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Mesh& a, Mesh& b) {
    a.Swap(&b);
  }
  inline void Swap(Mesh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mesh* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mesh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mesh>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mesh& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mesh& from) {
    Mesh::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mesh* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mc.comm.Mesh";
  }
  protected:
  explicit Mesh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrimitivesFieldNumber = 1,
  };
  // repeated .mc.comm.Primitive primitives = 1;
  int primitives_size() const;
  private:
  int _internal_primitives_size() const;
  public:
  void clear_primitives();
  ::mc::comm::Primitive* mutable_primitives(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Primitive >*
      mutable_primitives();
  private:
  const ::mc::comm::Primitive& _internal_primitives(int index) const;
  ::mc::comm::Primitive* _internal_add_primitives();
  public:
  const ::mc::comm::Primitive& primitives(int index) const;
  ::mc::comm::Primitive* add_primitives();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Primitive >&
      primitives() const;

  // @@protoc_insertion_point(class_scope:mc.comm.Mesh)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Primitive > primitives_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mc_2fcomm_2fgltf_2eproto;
};
// -------------------------------------------------------------------

class Texture final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mc.comm.Texture) */ {
 public:
  inline Texture() : Texture(nullptr) {}
  ~Texture() override;
  explicit PROTOBUF_CONSTEXPR Texture(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Texture(const Texture& from);
  Texture(Texture&& from) noexcept
    : Texture() {
    *this = ::std::move(from);
  }

  inline Texture& operator=(const Texture& from) {
    CopyFrom(from);
    return *this;
  }
  inline Texture& operator=(Texture&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Texture& default_instance() {
    return *internal_default_instance();
  }
  static inline const Texture* internal_default_instance() {
    return reinterpret_cast<const Texture*>(
               &_Texture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Texture& a, Texture& b) {
    a.Swap(&b);
  }
  inline void Swap(Texture* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Texture* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Texture* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Texture>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Texture& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Texture& from) {
    Texture::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Texture* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mc.comm.Texture";
  }
  protected:
  explicit Texture(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSamplerFieldNumber = 1,
    kSourceFieldNumber = 2,
  };
  // int32 sampler = 1;
  void clear_sampler();
  int32_t sampler() const;
  void set_sampler(int32_t value);
  private:
  int32_t _internal_sampler() const;
  void _internal_set_sampler(int32_t value);
  public:

  // int32 source = 2;
  void clear_source();
  int32_t source() const;
  void set_source(int32_t value);
  private:
  int32_t _internal_source() const;
  void _internal_set_source(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mc.comm.Texture)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t sampler_;
    int32_t source_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mc_2fcomm_2fgltf_2eproto;
};
// -------------------------------------------------------------------

class Image final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mc.comm.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  ~Image() override;
  explicit PROTOBUF_CONSTEXPR Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Image& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Image& from) {
    Image::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mc.comm.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // @@protoc_insertion_point(class_scope:mc.comm.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mc_2fcomm_2fgltf_2eproto;
};
// -------------------------------------------------------------------

class Sampler final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mc.comm.Sampler) */ {
 public:
  inline Sampler() : Sampler(nullptr) {}
  ~Sampler() override;
  explicit PROTOBUF_CONSTEXPR Sampler(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sampler(const Sampler& from);
  Sampler(Sampler&& from) noexcept
    : Sampler() {
    *this = ::std::move(from);
  }

  inline Sampler& operator=(const Sampler& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sampler& operator=(Sampler&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sampler& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sampler* internal_default_instance() {
    return reinterpret_cast<const Sampler*>(
               &_Sampler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Sampler& a, Sampler& b) {
    a.Swap(&b);
  }
  inline void Swap(Sampler* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sampler* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sampler* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sampler>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sampler& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sampler& from) {
    Sampler::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sampler* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mc.comm.Sampler";
  }
  protected:
  explicit Sampler(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMagFilterFieldNumber = 1,
    kMinFilterFieldNumber = 2,
    kWrapSFieldNumber = 3,
    kWrapTFieldNumber = 4,
  };
  // int32 magFilter = 1;
  void clear_magfilter();
  int32_t magfilter() const;
  void set_magfilter(int32_t value);
  private:
  int32_t _internal_magfilter() const;
  void _internal_set_magfilter(int32_t value);
  public:

  // int32 minFilter = 2;
  void clear_minfilter();
  int32_t minfilter() const;
  void set_minfilter(int32_t value);
  private:
  int32_t _internal_minfilter() const;
  void _internal_set_minfilter(int32_t value);
  public:

  // int32 wrapS = 3;
  void clear_wraps();
  int32_t wraps() const;
  void set_wraps(int32_t value);
  private:
  int32_t _internal_wraps() const;
  void _internal_set_wraps(int32_t value);
  public:

  // int32 wrapT = 4;
  void clear_wrapt();
  int32_t wrapt() const;
  void set_wrapt(int32_t value);
  private:
  int32_t _internal_wrapt() const;
  void _internal_set_wrapt(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mc.comm.Sampler)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t magfilter_;
    int32_t minfilter_;
    int32_t wraps_;
    int32_t wrapt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mc_2fcomm_2fgltf_2eproto;
};
// -------------------------------------------------------------------

class Buffer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mc.comm.Buffer) */ {
 public:
  inline Buffer() : Buffer(nullptr) {}
  ~Buffer() override;
  explicit PROTOBUF_CONSTEXPR Buffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Buffer(const Buffer& from);
  Buffer(Buffer&& from) noexcept
    : Buffer() {
    *this = ::std::move(from);
  }

  inline Buffer& operator=(const Buffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Buffer& operator=(Buffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Buffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Buffer* internal_default_instance() {
    return reinterpret_cast<const Buffer*>(
               &_Buffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Buffer& a, Buffer& b) {
    a.Swap(&b);
  }
  inline void Swap(Buffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Buffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Buffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Buffer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Buffer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Buffer& from) {
    Buffer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Buffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mc.comm.Buffer";
  }
  protected:
  explicit Buffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kByteLengthFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // int32 byteLength = 2;
  void clear_bytelength();
  int32_t bytelength() const;
  void set_bytelength(int32_t value);
  private:
  int32_t _internal_bytelength() const;
  void _internal_set_bytelength(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mc.comm.Buffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    int32_t bytelength_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mc_2fcomm_2fgltf_2eproto;
};
// -------------------------------------------------------------------

class BufferView final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mc.comm.BufferView) */ {
 public:
  inline BufferView() : BufferView(nullptr) {}
  ~BufferView() override;
  explicit PROTOBUF_CONSTEXPR BufferView(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BufferView(const BufferView& from);
  BufferView(BufferView&& from) noexcept
    : BufferView() {
    *this = ::std::move(from);
  }

  inline BufferView& operator=(const BufferView& from) {
    CopyFrom(from);
    return *this;
  }
  inline BufferView& operator=(BufferView&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BufferView& default_instance() {
    return *internal_default_instance();
  }
  static inline const BufferView* internal_default_instance() {
    return reinterpret_cast<const BufferView*>(
               &_BufferView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BufferView& a, BufferView& b) {
    a.Swap(&b);
  }
  inline void Swap(BufferView* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BufferView* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BufferView* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BufferView>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BufferView& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BufferView& from) {
    BufferView::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BufferView* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mc.comm.BufferView";
  }
  protected:
  explicit BufferView(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 1,
    kByteOffsetFieldNumber = 2,
    kByteLengthFieldNumber = 3,
    kByteStrideFieldNumber = 4,
    kTargetFieldNumber = 5,
  };
  // int32 buffer = 1;
  void clear_buffer();
  int32_t buffer() const;
  void set_buffer(int32_t value);
  private:
  int32_t _internal_buffer() const;
  void _internal_set_buffer(int32_t value);
  public:

  // int32 byteOffset = 2;
  void clear_byteoffset();
  int32_t byteoffset() const;
  void set_byteoffset(int32_t value);
  private:
  int32_t _internal_byteoffset() const;
  void _internal_set_byteoffset(int32_t value);
  public:

  // int32 byteLength = 3;
  void clear_bytelength();
  int32_t bytelength() const;
  void set_bytelength(int32_t value);
  private:
  int32_t _internal_bytelength() const;
  void _internal_set_bytelength(int32_t value);
  public:

  // int32 byteStride = 4;
  void clear_bytestride();
  int32_t bytestride() const;
  void set_bytestride(int32_t value);
  private:
  int32_t _internal_bytestride() const;
  void _internal_set_bytestride(int32_t value);
  public:

  // int32 target = 5;
  void clear_target();
  int32_t target() const;
  void set_target(int32_t value);
  private:
  int32_t _internal_target() const;
  void _internal_set_target(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mc.comm.BufferView)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t buffer_;
    int32_t byteoffset_;
    int32_t bytelength_;
    int32_t bytestride_;
    int32_t target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mc_2fcomm_2fgltf_2eproto;
};
// -------------------------------------------------------------------

class Accessor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mc.comm.Accessor) */ {
 public:
  inline Accessor() : Accessor(nullptr) {}
  ~Accessor() override;
  explicit PROTOBUF_CONSTEXPR Accessor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Accessor(const Accessor& from);
  Accessor(Accessor&& from) noexcept
    : Accessor() {
    *this = ::std::move(from);
  }

  inline Accessor& operator=(const Accessor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Accessor& operator=(Accessor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Accessor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Accessor* internal_default_instance() {
    return reinterpret_cast<const Accessor*>(
               &_Accessor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Accessor& a, Accessor& b) {
    a.Swap(&b);
  }
  inline void Swap(Accessor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Accessor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Accessor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Accessor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Accessor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Accessor& from) {
    Accessor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Accessor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mc.comm.Accessor";
  }
  protected:
  explicit Accessor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxFieldNumber = 6,
    kMinFieldNumber = 7,
    kTypeFieldNumber = 5,
    kBufferViewFieldNumber = 1,
    kByteOffsetFieldNumber = 2,
    kComponentTypeFieldNumber = 3,
    kCountFieldNumber = 4,
  };
  // repeated float max = 6;
  int max_size() const;
  private:
  int _internal_max_size() const;
  public:
  void clear_max();
  private:
  float _internal_max(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_max() const;
  void _internal_add_max(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_max();
  public:
  float max(int index) const;
  void set_max(int index, float value);
  void add_max(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      max() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_max();

  // repeated float min = 7;
  int min_size() const;
  private:
  int _internal_min_size() const;
  public:
  void clear_min();
  private:
  float _internal_min(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_min() const;
  void _internal_add_min(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_min();
  public:
  float min(int index) const;
  void set_min(int index, float value);
  void add_min(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      min() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_min();

  // string type = 5;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // int32 bufferView = 1;
  void clear_bufferview();
  int32_t bufferview() const;
  void set_bufferview(int32_t value);
  private:
  int32_t _internal_bufferview() const;
  void _internal_set_bufferview(int32_t value);
  public:

  // int32 byteOffset = 2;
  void clear_byteoffset();
  int32_t byteoffset() const;
  void set_byteoffset(int32_t value);
  private:
  int32_t _internal_byteoffset() const;
  void _internal_set_byteoffset(int32_t value);
  public:

  // int32 componentType = 3;
  void clear_componenttype();
  int32_t componenttype() const;
  void set_componenttype(int32_t value);
  private:
  int32_t _internal_componenttype() const;
  void _internal_set_componenttype(int32_t value);
  public:

  // int32 count = 4;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mc.comm.Accessor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > max_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > min_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    int32_t bufferview_;
    int32_t byteoffset_;
    int32_t componenttype_;
    int32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mc_2fcomm_2fgltf_2eproto;
};
// -------------------------------------------------------------------

class Asset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mc.comm.Asset) */ {
 public:
  inline Asset() : Asset(nullptr) {}
  ~Asset() override;
  explicit PROTOBUF_CONSTEXPR Asset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Asset(const Asset& from);
  Asset(Asset&& from) noexcept
    : Asset() {
    *this = ::std::move(from);
  }

  inline Asset& operator=(const Asset& from) {
    CopyFrom(from);
    return *this;
  }
  inline Asset& operator=(Asset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Asset& default_instance() {
    return *internal_default_instance();
  }
  static inline const Asset* internal_default_instance() {
    return reinterpret_cast<const Asset*>(
               &_Asset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Asset& a, Asset& b) {
    a.Swap(&b);
  }
  inline void Swap(Asset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Asset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Asset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Asset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Asset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Asset& from) {
    Asset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Asset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mc.comm.Asset";
  }
  protected:
  explicit Asset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:mc.comm.Asset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mc_2fcomm_2fgltf_2eproto;
};
// -------------------------------------------------------------------

class GLTF final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mc.comm.GLTF) */ {
 public:
  inline GLTF() : GLTF(nullptr) {}
  ~GLTF() override;
  explicit PROTOBUF_CONSTEXPR GLTF(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GLTF(const GLTF& from);
  GLTF(GLTF&& from) noexcept
    : GLTF() {
    *this = ::std::move(from);
  }

  inline GLTF& operator=(const GLTF& from) {
    CopyFrom(from);
    return *this;
  }
  inline GLTF& operator=(GLTF&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GLTF& default_instance() {
    return *internal_default_instance();
  }
  static inline const GLTF* internal_default_instance() {
    return reinterpret_cast<const GLTF*>(
               &_GLTF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GLTF& a, GLTF& b) {
    a.Swap(&b);
  }
  inline void Swap(GLTF* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GLTF* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GLTF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GLTF>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GLTF& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GLTF& from) {
    GLTF::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GLTF* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mc.comm.GLTF";
  }
  protected:
  explicit GLTF(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScenesFieldNumber = 2,
    kNodesFieldNumber = 3,
    kMeshesFieldNumber = 4,
    kTexturesFieldNumber = 5,
    kImagesFieldNumber = 6,
    kSamplersFieldNumber = 7,
    kBuffersFieldNumber = 8,
    kBufferViewsFieldNumber = 9,
    kAccessorsFieldNumber = 10,
    kAssetFieldNumber = 11,
    kSceneFieldNumber = 1,
  };
  // repeated .mc.comm.Scene scenes = 2;
  int scenes_size() const;
  private:
  int _internal_scenes_size() const;
  public:
  void clear_scenes();
  ::mc::comm::Scene* mutable_scenes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Scene >*
      mutable_scenes();
  private:
  const ::mc::comm::Scene& _internal_scenes(int index) const;
  ::mc::comm::Scene* _internal_add_scenes();
  public:
  const ::mc::comm::Scene& scenes(int index) const;
  ::mc::comm::Scene* add_scenes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Scene >&
      scenes() const;

  // repeated .mc.comm.Node nodes = 3;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::mc::comm::Node* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Node >*
      mutable_nodes();
  private:
  const ::mc::comm::Node& _internal_nodes(int index) const;
  ::mc::comm::Node* _internal_add_nodes();
  public:
  const ::mc::comm::Node& nodes(int index) const;
  ::mc::comm::Node* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Node >&
      nodes() const;

  // repeated .mc.comm.Mesh meshes = 4;
  int meshes_size() const;
  private:
  int _internal_meshes_size() const;
  public:
  void clear_meshes();
  ::mc::comm::Mesh* mutable_meshes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Mesh >*
      mutable_meshes();
  private:
  const ::mc::comm::Mesh& _internal_meshes(int index) const;
  ::mc::comm::Mesh* _internal_add_meshes();
  public:
  const ::mc::comm::Mesh& meshes(int index) const;
  ::mc::comm::Mesh* add_meshes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Mesh >&
      meshes() const;

  // repeated .mc.comm.Texture textures = 5;
  int textures_size() const;
  private:
  int _internal_textures_size() const;
  public:
  void clear_textures();
  ::mc::comm::Texture* mutable_textures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Texture >*
      mutable_textures();
  private:
  const ::mc::comm::Texture& _internal_textures(int index) const;
  ::mc::comm::Texture* _internal_add_textures();
  public:
  const ::mc::comm::Texture& textures(int index) const;
  ::mc::comm::Texture* add_textures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Texture >&
      textures() const;

  // repeated .mc.comm.Image images = 6;
  int images_size() const;
  private:
  int _internal_images_size() const;
  public:
  void clear_images();
  ::mc::comm::Image* mutable_images(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Image >*
      mutable_images();
  private:
  const ::mc::comm::Image& _internal_images(int index) const;
  ::mc::comm::Image* _internal_add_images();
  public:
  const ::mc::comm::Image& images(int index) const;
  ::mc::comm::Image* add_images();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Image >&
      images() const;

  // repeated .mc.comm.Sampler samplers = 7;
  int samplers_size() const;
  private:
  int _internal_samplers_size() const;
  public:
  void clear_samplers();
  ::mc::comm::Sampler* mutable_samplers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Sampler >*
      mutable_samplers();
  private:
  const ::mc::comm::Sampler& _internal_samplers(int index) const;
  ::mc::comm::Sampler* _internal_add_samplers();
  public:
  const ::mc::comm::Sampler& samplers(int index) const;
  ::mc::comm::Sampler* add_samplers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Sampler >&
      samplers() const;

  // repeated .mc.comm.Buffer buffers = 8;
  int buffers_size() const;
  private:
  int _internal_buffers_size() const;
  public:
  void clear_buffers();
  ::mc::comm::Buffer* mutable_buffers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Buffer >*
      mutable_buffers();
  private:
  const ::mc::comm::Buffer& _internal_buffers(int index) const;
  ::mc::comm::Buffer* _internal_add_buffers();
  public:
  const ::mc::comm::Buffer& buffers(int index) const;
  ::mc::comm::Buffer* add_buffers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Buffer >&
      buffers() const;

  // repeated .mc.comm.BufferView bufferViews = 9;
  int bufferviews_size() const;
  private:
  int _internal_bufferviews_size() const;
  public:
  void clear_bufferviews();
  ::mc::comm::BufferView* mutable_bufferviews(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::BufferView >*
      mutable_bufferviews();
  private:
  const ::mc::comm::BufferView& _internal_bufferviews(int index) const;
  ::mc::comm::BufferView* _internal_add_bufferviews();
  public:
  const ::mc::comm::BufferView& bufferviews(int index) const;
  ::mc::comm::BufferView* add_bufferviews();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::BufferView >&
      bufferviews() const;

  // repeated .mc.comm.Accessor accessors = 10;
  int accessors_size() const;
  private:
  int _internal_accessors_size() const;
  public:
  void clear_accessors();
  ::mc::comm::Accessor* mutable_accessors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Accessor >*
      mutable_accessors();
  private:
  const ::mc::comm::Accessor& _internal_accessors(int index) const;
  ::mc::comm::Accessor* _internal_add_accessors();
  public:
  const ::mc::comm::Accessor& accessors(int index) const;
  ::mc::comm::Accessor* add_accessors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Accessor >&
      accessors() const;

  // .mc.comm.Asset asset = 11;
  bool has_asset() const;
  private:
  bool _internal_has_asset() const;
  public:
  void clear_asset();
  const ::mc::comm::Asset& asset() const;
  PROTOBUF_NODISCARD ::mc::comm::Asset* release_asset();
  ::mc::comm::Asset* mutable_asset();
  void set_allocated_asset(::mc::comm::Asset* asset);
  private:
  const ::mc::comm::Asset& _internal_asset() const;
  ::mc::comm::Asset* _internal_mutable_asset();
  public:
  void unsafe_arena_set_allocated_asset(
      ::mc::comm::Asset* asset);
  ::mc::comm::Asset* unsafe_arena_release_asset();

  // int32 scene = 1;
  void clear_scene();
  int32_t scene() const;
  void set_scene(int32_t value);
  private:
  int32_t _internal_scene() const;
  void _internal_set_scene(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mc.comm.GLTF)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Scene > scenes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Node > nodes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Mesh > meshes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Texture > textures_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Image > images_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Sampler > samplers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Buffer > buffers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::BufferView > bufferviews_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Accessor > accessors_;
    ::mc::comm::Asset* asset_;
    int32_t scene_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mc_2fcomm_2fgltf_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Scene

// repeated int32 nodes = 1;
inline int Scene::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int Scene::nodes_size() const {
  return _internal_nodes_size();
}
inline void Scene::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline int32_t Scene::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline int32_t Scene::nodes(int index) const {
  // @@protoc_insertion_point(field_get:mc.comm.Scene.nodes)
  return _internal_nodes(index);
}
inline void Scene::set_nodes(int index, int32_t value) {
  _impl_.nodes_.Set(index, value);
  // @@protoc_insertion_point(field_set:mc.comm.Scene.nodes)
}
inline void Scene::_internal_add_nodes(int32_t value) {
  _impl_.nodes_.Add(value);
}
inline void Scene::add_nodes(int32_t value) {
  _internal_add_nodes(value);
  // @@protoc_insertion_point(field_add:mc.comm.Scene.nodes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Scene::_internal_nodes() const {
  return _impl_.nodes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Scene::nodes() const {
  // @@protoc_insertion_point(field_list:mc.comm.Scene.nodes)
  return _internal_nodes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Scene::_internal_mutable_nodes() {
  return &_impl_.nodes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Scene::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:mc.comm.Scene.nodes)
  return _internal_mutable_nodes();
}

// -------------------------------------------------------------------

// Node

// int32 mesh = 1;
inline void Node::clear_mesh() {
  _impl_.mesh_ = 0;
}
inline int32_t Node::_internal_mesh() const {
  return _impl_.mesh_;
}
inline int32_t Node::mesh() const {
  // @@protoc_insertion_point(field_get:mc.comm.Node.mesh)
  return _internal_mesh();
}
inline void Node::_internal_set_mesh(int32_t value) {
  
  _impl_.mesh_ = value;
}
inline void Node::set_mesh(int32_t value) {
  _internal_set_mesh(value);
  // @@protoc_insertion_point(field_set:mc.comm.Node.mesh)
}

// -------------------------------------------------------------------

// Attributes

// int32 POSITION = 1;
inline void Attributes::clear_position() {
  _impl_.position_ = 0;
}
inline int32_t Attributes::_internal_position() const {
  return _impl_.position_;
}
inline int32_t Attributes::position() const {
  // @@protoc_insertion_point(field_get:mc.comm.Attributes.POSITION)
  return _internal_position();
}
inline void Attributes::_internal_set_position(int32_t value) {
  
  _impl_.position_ = value;
}
inline void Attributes::set_position(int32_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:mc.comm.Attributes.POSITION)
}

// int32 NORMAL = 2;
inline void Attributes::clear_normal() {
  _impl_.normal_ = 0;
}
inline int32_t Attributes::_internal_normal() const {
  return _impl_.normal_;
}
inline int32_t Attributes::normal() const {
  // @@protoc_insertion_point(field_get:mc.comm.Attributes.NORMAL)
  return _internal_normal();
}
inline void Attributes::_internal_set_normal(int32_t value) {
  
  _impl_.normal_ = value;
}
inline void Attributes::set_normal(int32_t value) {
  _internal_set_normal(value);
  // @@protoc_insertion_point(field_set:mc.comm.Attributes.NORMAL)
}

// int32 TEXCOORD_0 = 3;
inline void Attributes::clear_texcoord_0() {
  _impl_.texcoord_0_ = 0;
}
inline int32_t Attributes::_internal_texcoord_0() const {
  return _impl_.texcoord_0_;
}
inline int32_t Attributes::texcoord_0() const {
  // @@protoc_insertion_point(field_get:mc.comm.Attributes.TEXCOORD_0)
  return _internal_texcoord_0();
}
inline void Attributes::_internal_set_texcoord_0(int32_t value) {
  
  _impl_.texcoord_0_ = value;
}
inline void Attributes::set_texcoord_0(int32_t value) {
  _internal_set_texcoord_0(value);
  // @@protoc_insertion_point(field_set:mc.comm.Attributes.TEXCOORD_0)
}

// -------------------------------------------------------------------

// Primitive

// int32 indices = 1;
inline void Primitive::clear_indices() {
  _impl_.indices_ = 0;
}
inline int32_t Primitive::_internal_indices() const {
  return _impl_.indices_;
}
inline int32_t Primitive::indices() const {
  // @@protoc_insertion_point(field_get:mc.comm.Primitive.indices)
  return _internal_indices();
}
inline void Primitive::_internal_set_indices(int32_t value) {
  
  _impl_.indices_ = value;
}
inline void Primitive::set_indices(int32_t value) {
  _internal_set_indices(value);
  // @@protoc_insertion_point(field_set:mc.comm.Primitive.indices)
}

// .mc.comm.Attributes attributes = 2;
inline bool Primitive::_internal_has_attributes() const {
  return this != internal_default_instance() && _impl_.attributes_ != nullptr;
}
inline bool Primitive::has_attributes() const {
  return _internal_has_attributes();
}
inline void Primitive::clear_attributes() {
  if (GetArenaForAllocation() == nullptr && _impl_.attributes_ != nullptr) {
    delete _impl_.attributes_;
  }
  _impl_.attributes_ = nullptr;
}
inline const ::mc::comm::Attributes& Primitive::_internal_attributes() const {
  const ::mc::comm::Attributes* p = _impl_.attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::mc::comm::Attributes&>(
      ::mc::comm::_Attributes_default_instance_);
}
inline const ::mc::comm::Attributes& Primitive::attributes() const {
  // @@protoc_insertion_point(field_get:mc.comm.Primitive.attributes)
  return _internal_attributes();
}
inline void Primitive::unsafe_arena_set_allocated_attributes(
    ::mc::comm::Attributes* attributes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attributes_);
  }
  _impl_.attributes_ = attributes;
  if (attributes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mc.comm.Primitive.attributes)
}
inline ::mc::comm::Attributes* Primitive::release_attributes() {
  
  ::mc::comm::Attributes* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mc::comm::Attributes* Primitive::unsafe_arena_release_attributes() {
  // @@protoc_insertion_point(field_release:mc.comm.Primitive.attributes)
  
  ::mc::comm::Attributes* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
  return temp;
}
inline ::mc::comm::Attributes* Primitive::_internal_mutable_attributes() {
  
  if (_impl_.attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::mc::comm::Attributes>(GetArenaForAllocation());
    _impl_.attributes_ = p;
  }
  return _impl_.attributes_;
}
inline ::mc::comm::Attributes* Primitive::mutable_attributes() {
  ::mc::comm::Attributes* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:mc.comm.Primitive.attributes)
  return _msg;
}
inline void Primitive::set_allocated_attributes(::mc::comm::Attributes* attributes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attributes_;
  }
  if (attributes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attributes);
    if (message_arena != submessage_arena) {
      attributes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attributes, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.attributes_ = attributes;
  // @@protoc_insertion_point(field_set_allocated:mc.comm.Primitive.attributes)
}

// -------------------------------------------------------------------

// Mesh

// repeated .mc.comm.Primitive primitives = 1;
inline int Mesh::_internal_primitives_size() const {
  return _impl_.primitives_.size();
}
inline int Mesh::primitives_size() const {
  return _internal_primitives_size();
}
inline void Mesh::clear_primitives() {
  _impl_.primitives_.Clear();
}
inline ::mc::comm::Primitive* Mesh::mutable_primitives(int index) {
  // @@protoc_insertion_point(field_mutable:mc.comm.Mesh.primitives)
  return _impl_.primitives_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Primitive >*
Mesh::mutable_primitives() {
  // @@protoc_insertion_point(field_mutable_list:mc.comm.Mesh.primitives)
  return &_impl_.primitives_;
}
inline const ::mc::comm::Primitive& Mesh::_internal_primitives(int index) const {
  return _impl_.primitives_.Get(index);
}
inline const ::mc::comm::Primitive& Mesh::primitives(int index) const {
  // @@protoc_insertion_point(field_get:mc.comm.Mesh.primitives)
  return _internal_primitives(index);
}
inline ::mc::comm::Primitive* Mesh::_internal_add_primitives() {
  return _impl_.primitives_.Add();
}
inline ::mc::comm::Primitive* Mesh::add_primitives() {
  ::mc::comm::Primitive* _add = _internal_add_primitives();
  // @@protoc_insertion_point(field_add:mc.comm.Mesh.primitives)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Primitive >&
Mesh::primitives() const {
  // @@protoc_insertion_point(field_list:mc.comm.Mesh.primitives)
  return _impl_.primitives_;
}

// -------------------------------------------------------------------

// Texture

// int32 sampler = 1;
inline void Texture::clear_sampler() {
  _impl_.sampler_ = 0;
}
inline int32_t Texture::_internal_sampler() const {
  return _impl_.sampler_;
}
inline int32_t Texture::sampler() const {
  // @@protoc_insertion_point(field_get:mc.comm.Texture.sampler)
  return _internal_sampler();
}
inline void Texture::_internal_set_sampler(int32_t value) {
  
  _impl_.sampler_ = value;
}
inline void Texture::set_sampler(int32_t value) {
  _internal_set_sampler(value);
  // @@protoc_insertion_point(field_set:mc.comm.Texture.sampler)
}

// int32 source = 2;
inline void Texture::clear_source() {
  _impl_.source_ = 0;
}
inline int32_t Texture::_internal_source() const {
  return _impl_.source_;
}
inline int32_t Texture::source() const {
  // @@protoc_insertion_point(field_get:mc.comm.Texture.source)
  return _internal_source();
}
inline void Texture::_internal_set_source(int32_t value) {
  
  _impl_.source_ = value;
}
inline void Texture::set_source(int32_t value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:mc.comm.Texture.source)
}

// -------------------------------------------------------------------

// Image

// string uri = 1;
inline void Image::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& Image::uri() const {
  // @@protoc_insertion_point(field_get:mc.comm.Image.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mc.comm.Image.uri)
}
inline std::string* Image::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:mc.comm.Image.uri)
  return _s;
}
inline const std::string& Image::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void Image::_internal_set_uri(const std::string& value) {
  
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_uri() {
  
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_uri() {
  // @@protoc_insertion_point(field_release:mc.comm.Image.uri)
  return _impl_.uri_.Release();
}
inline void Image::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mc.comm.Image.uri)
}

// -------------------------------------------------------------------

// Sampler

// int32 magFilter = 1;
inline void Sampler::clear_magfilter() {
  _impl_.magfilter_ = 0;
}
inline int32_t Sampler::_internal_magfilter() const {
  return _impl_.magfilter_;
}
inline int32_t Sampler::magfilter() const {
  // @@protoc_insertion_point(field_get:mc.comm.Sampler.magFilter)
  return _internal_magfilter();
}
inline void Sampler::_internal_set_magfilter(int32_t value) {
  
  _impl_.magfilter_ = value;
}
inline void Sampler::set_magfilter(int32_t value) {
  _internal_set_magfilter(value);
  // @@protoc_insertion_point(field_set:mc.comm.Sampler.magFilter)
}

// int32 minFilter = 2;
inline void Sampler::clear_minfilter() {
  _impl_.minfilter_ = 0;
}
inline int32_t Sampler::_internal_minfilter() const {
  return _impl_.minfilter_;
}
inline int32_t Sampler::minfilter() const {
  // @@protoc_insertion_point(field_get:mc.comm.Sampler.minFilter)
  return _internal_minfilter();
}
inline void Sampler::_internal_set_minfilter(int32_t value) {
  
  _impl_.minfilter_ = value;
}
inline void Sampler::set_minfilter(int32_t value) {
  _internal_set_minfilter(value);
  // @@protoc_insertion_point(field_set:mc.comm.Sampler.minFilter)
}

// int32 wrapS = 3;
inline void Sampler::clear_wraps() {
  _impl_.wraps_ = 0;
}
inline int32_t Sampler::_internal_wraps() const {
  return _impl_.wraps_;
}
inline int32_t Sampler::wraps() const {
  // @@protoc_insertion_point(field_get:mc.comm.Sampler.wrapS)
  return _internal_wraps();
}
inline void Sampler::_internal_set_wraps(int32_t value) {
  
  _impl_.wraps_ = value;
}
inline void Sampler::set_wraps(int32_t value) {
  _internal_set_wraps(value);
  // @@protoc_insertion_point(field_set:mc.comm.Sampler.wrapS)
}

// int32 wrapT = 4;
inline void Sampler::clear_wrapt() {
  _impl_.wrapt_ = 0;
}
inline int32_t Sampler::_internal_wrapt() const {
  return _impl_.wrapt_;
}
inline int32_t Sampler::wrapt() const {
  // @@protoc_insertion_point(field_get:mc.comm.Sampler.wrapT)
  return _internal_wrapt();
}
inline void Sampler::_internal_set_wrapt(int32_t value) {
  
  _impl_.wrapt_ = value;
}
inline void Sampler::set_wrapt(int32_t value) {
  _internal_set_wrapt(value);
  // @@protoc_insertion_point(field_set:mc.comm.Sampler.wrapT)
}

// -------------------------------------------------------------------

// Buffer

// string uri = 1;
inline void Buffer::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& Buffer::uri() const {
  // @@protoc_insertion_point(field_get:mc.comm.Buffer.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Buffer::set_uri(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mc.comm.Buffer.uri)
}
inline std::string* Buffer::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:mc.comm.Buffer.uri)
  return _s;
}
inline const std::string& Buffer::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void Buffer::_internal_set_uri(const std::string& value) {
  
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* Buffer::_internal_mutable_uri() {
  
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* Buffer::release_uri() {
  // @@protoc_insertion_point(field_release:mc.comm.Buffer.uri)
  return _impl_.uri_.Release();
}
inline void Buffer::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mc.comm.Buffer.uri)
}

// int32 byteLength = 2;
inline void Buffer::clear_bytelength() {
  _impl_.bytelength_ = 0;
}
inline int32_t Buffer::_internal_bytelength() const {
  return _impl_.bytelength_;
}
inline int32_t Buffer::bytelength() const {
  // @@protoc_insertion_point(field_get:mc.comm.Buffer.byteLength)
  return _internal_bytelength();
}
inline void Buffer::_internal_set_bytelength(int32_t value) {
  
  _impl_.bytelength_ = value;
}
inline void Buffer::set_bytelength(int32_t value) {
  _internal_set_bytelength(value);
  // @@protoc_insertion_point(field_set:mc.comm.Buffer.byteLength)
}

// -------------------------------------------------------------------

// BufferView

// int32 buffer = 1;
inline void BufferView::clear_buffer() {
  _impl_.buffer_ = 0;
}
inline int32_t BufferView::_internal_buffer() const {
  return _impl_.buffer_;
}
inline int32_t BufferView::buffer() const {
  // @@protoc_insertion_point(field_get:mc.comm.BufferView.buffer)
  return _internal_buffer();
}
inline void BufferView::_internal_set_buffer(int32_t value) {
  
  _impl_.buffer_ = value;
}
inline void BufferView::set_buffer(int32_t value) {
  _internal_set_buffer(value);
  // @@protoc_insertion_point(field_set:mc.comm.BufferView.buffer)
}

// int32 byteOffset = 2;
inline void BufferView::clear_byteoffset() {
  _impl_.byteoffset_ = 0;
}
inline int32_t BufferView::_internal_byteoffset() const {
  return _impl_.byteoffset_;
}
inline int32_t BufferView::byteoffset() const {
  // @@protoc_insertion_point(field_get:mc.comm.BufferView.byteOffset)
  return _internal_byteoffset();
}
inline void BufferView::_internal_set_byteoffset(int32_t value) {
  
  _impl_.byteoffset_ = value;
}
inline void BufferView::set_byteoffset(int32_t value) {
  _internal_set_byteoffset(value);
  // @@protoc_insertion_point(field_set:mc.comm.BufferView.byteOffset)
}

// int32 byteLength = 3;
inline void BufferView::clear_bytelength() {
  _impl_.bytelength_ = 0;
}
inline int32_t BufferView::_internal_bytelength() const {
  return _impl_.bytelength_;
}
inline int32_t BufferView::bytelength() const {
  // @@protoc_insertion_point(field_get:mc.comm.BufferView.byteLength)
  return _internal_bytelength();
}
inline void BufferView::_internal_set_bytelength(int32_t value) {
  
  _impl_.bytelength_ = value;
}
inline void BufferView::set_bytelength(int32_t value) {
  _internal_set_bytelength(value);
  // @@protoc_insertion_point(field_set:mc.comm.BufferView.byteLength)
}

// int32 byteStride = 4;
inline void BufferView::clear_bytestride() {
  _impl_.bytestride_ = 0;
}
inline int32_t BufferView::_internal_bytestride() const {
  return _impl_.bytestride_;
}
inline int32_t BufferView::bytestride() const {
  // @@protoc_insertion_point(field_get:mc.comm.BufferView.byteStride)
  return _internal_bytestride();
}
inline void BufferView::_internal_set_bytestride(int32_t value) {
  
  _impl_.bytestride_ = value;
}
inline void BufferView::set_bytestride(int32_t value) {
  _internal_set_bytestride(value);
  // @@protoc_insertion_point(field_set:mc.comm.BufferView.byteStride)
}

// int32 target = 5;
inline void BufferView::clear_target() {
  _impl_.target_ = 0;
}
inline int32_t BufferView::_internal_target() const {
  return _impl_.target_;
}
inline int32_t BufferView::target() const {
  // @@protoc_insertion_point(field_get:mc.comm.BufferView.target)
  return _internal_target();
}
inline void BufferView::_internal_set_target(int32_t value) {
  
  _impl_.target_ = value;
}
inline void BufferView::set_target(int32_t value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:mc.comm.BufferView.target)
}

// -------------------------------------------------------------------

// Accessor

// int32 bufferView = 1;
inline void Accessor::clear_bufferview() {
  _impl_.bufferview_ = 0;
}
inline int32_t Accessor::_internal_bufferview() const {
  return _impl_.bufferview_;
}
inline int32_t Accessor::bufferview() const {
  // @@protoc_insertion_point(field_get:mc.comm.Accessor.bufferView)
  return _internal_bufferview();
}
inline void Accessor::_internal_set_bufferview(int32_t value) {
  
  _impl_.bufferview_ = value;
}
inline void Accessor::set_bufferview(int32_t value) {
  _internal_set_bufferview(value);
  // @@protoc_insertion_point(field_set:mc.comm.Accessor.bufferView)
}

// int32 byteOffset = 2;
inline void Accessor::clear_byteoffset() {
  _impl_.byteoffset_ = 0;
}
inline int32_t Accessor::_internal_byteoffset() const {
  return _impl_.byteoffset_;
}
inline int32_t Accessor::byteoffset() const {
  // @@protoc_insertion_point(field_get:mc.comm.Accessor.byteOffset)
  return _internal_byteoffset();
}
inline void Accessor::_internal_set_byteoffset(int32_t value) {
  
  _impl_.byteoffset_ = value;
}
inline void Accessor::set_byteoffset(int32_t value) {
  _internal_set_byteoffset(value);
  // @@protoc_insertion_point(field_set:mc.comm.Accessor.byteOffset)
}

// int32 componentType = 3;
inline void Accessor::clear_componenttype() {
  _impl_.componenttype_ = 0;
}
inline int32_t Accessor::_internal_componenttype() const {
  return _impl_.componenttype_;
}
inline int32_t Accessor::componenttype() const {
  // @@protoc_insertion_point(field_get:mc.comm.Accessor.componentType)
  return _internal_componenttype();
}
inline void Accessor::_internal_set_componenttype(int32_t value) {
  
  _impl_.componenttype_ = value;
}
inline void Accessor::set_componenttype(int32_t value) {
  _internal_set_componenttype(value);
  // @@protoc_insertion_point(field_set:mc.comm.Accessor.componentType)
}

// int32 count = 4;
inline void Accessor::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t Accessor::_internal_count() const {
  return _impl_.count_;
}
inline int32_t Accessor::count() const {
  // @@protoc_insertion_point(field_get:mc.comm.Accessor.count)
  return _internal_count();
}
inline void Accessor::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void Accessor::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:mc.comm.Accessor.count)
}

// string type = 5;
inline void Accessor::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Accessor::type() const {
  // @@protoc_insertion_point(field_get:mc.comm.Accessor.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Accessor::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mc.comm.Accessor.type)
}
inline std::string* Accessor::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:mc.comm.Accessor.type)
  return _s;
}
inline const std::string& Accessor::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Accessor::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Accessor::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Accessor::release_type() {
  // @@protoc_insertion_point(field_release:mc.comm.Accessor.type)
  return _impl_.type_.Release();
}
inline void Accessor::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mc.comm.Accessor.type)
}

// repeated float max = 6;
inline int Accessor::_internal_max_size() const {
  return _impl_.max_.size();
}
inline int Accessor::max_size() const {
  return _internal_max_size();
}
inline void Accessor::clear_max() {
  _impl_.max_.Clear();
}
inline float Accessor::_internal_max(int index) const {
  return _impl_.max_.Get(index);
}
inline float Accessor::max(int index) const {
  // @@protoc_insertion_point(field_get:mc.comm.Accessor.max)
  return _internal_max(index);
}
inline void Accessor::set_max(int index, float value) {
  _impl_.max_.Set(index, value);
  // @@protoc_insertion_point(field_set:mc.comm.Accessor.max)
}
inline void Accessor::_internal_add_max(float value) {
  _impl_.max_.Add(value);
}
inline void Accessor::add_max(float value) {
  _internal_add_max(value);
  // @@protoc_insertion_point(field_add:mc.comm.Accessor.max)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Accessor::_internal_max() const {
  return _impl_.max_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Accessor::max() const {
  // @@protoc_insertion_point(field_list:mc.comm.Accessor.max)
  return _internal_max();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Accessor::_internal_mutable_max() {
  return &_impl_.max_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Accessor::mutable_max() {
  // @@protoc_insertion_point(field_mutable_list:mc.comm.Accessor.max)
  return _internal_mutable_max();
}

// repeated float min = 7;
inline int Accessor::_internal_min_size() const {
  return _impl_.min_.size();
}
inline int Accessor::min_size() const {
  return _internal_min_size();
}
inline void Accessor::clear_min() {
  _impl_.min_.Clear();
}
inline float Accessor::_internal_min(int index) const {
  return _impl_.min_.Get(index);
}
inline float Accessor::min(int index) const {
  // @@protoc_insertion_point(field_get:mc.comm.Accessor.min)
  return _internal_min(index);
}
inline void Accessor::set_min(int index, float value) {
  _impl_.min_.Set(index, value);
  // @@protoc_insertion_point(field_set:mc.comm.Accessor.min)
}
inline void Accessor::_internal_add_min(float value) {
  _impl_.min_.Add(value);
}
inline void Accessor::add_min(float value) {
  _internal_add_min(value);
  // @@protoc_insertion_point(field_add:mc.comm.Accessor.min)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Accessor::_internal_min() const {
  return _impl_.min_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Accessor::min() const {
  // @@protoc_insertion_point(field_list:mc.comm.Accessor.min)
  return _internal_min();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Accessor::_internal_mutable_min() {
  return &_impl_.min_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Accessor::mutable_min() {
  // @@protoc_insertion_point(field_mutable_list:mc.comm.Accessor.min)
  return _internal_mutable_min();
}

// -------------------------------------------------------------------

// Asset

// string version = 1;
inline void Asset::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Asset::version() const {
  // @@protoc_insertion_point(field_get:mc.comm.Asset.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Asset::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mc.comm.Asset.version)
}
inline std::string* Asset::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:mc.comm.Asset.version)
  return _s;
}
inline const std::string& Asset::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Asset::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Asset::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Asset::release_version() {
  // @@protoc_insertion_point(field_release:mc.comm.Asset.version)
  return _impl_.version_.Release();
}
inline void Asset::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mc.comm.Asset.version)
}

// -------------------------------------------------------------------

// GLTF

// int32 scene = 1;
inline void GLTF::clear_scene() {
  _impl_.scene_ = 0;
}
inline int32_t GLTF::_internal_scene() const {
  return _impl_.scene_;
}
inline int32_t GLTF::scene() const {
  // @@protoc_insertion_point(field_get:mc.comm.GLTF.scene)
  return _internal_scene();
}
inline void GLTF::_internal_set_scene(int32_t value) {
  
  _impl_.scene_ = value;
}
inline void GLTF::set_scene(int32_t value) {
  _internal_set_scene(value);
  // @@protoc_insertion_point(field_set:mc.comm.GLTF.scene)
}

// repeated .mc.comm.Scene scenes = 2;
inline int GLTF::_internal_scenes_size() const {
  return _impl_.scenes_.size();
}
inline int GLTF::scenes_size() const {
  return _internal_scenes_size();
}
inline void GLTF::clear_scenes() {
  _impl_.scenes_.Clear();
}
inline ::mc::comm::Scene* GLTF::mutable_scenes(int index) {
  // @@protoc_insertion_point(field_mutable:mc.comm.GLTF.scenes)
  return _impl_.scenes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Scene >*
GLTF::mutable_scenes() {
  // @@protoc_insertion_point(field_mutable_list:mc.comm.GLTF.scenes)
  return &_impl_.scenes_;
}
inline const ::mc::comm::Scene& GLTF::_internal_scenes(int index) const {
  return _impl_.scenes_.Get(index);
}
inline const ::mc::comm::Scene& GLTF::scenes(int index) const {
  // @@protoc_insertion_point(field_get:mc.comm.GLTF.scenes)
  return _internal_scenes(index);
}
inline ::mc::comm::Scene* GLTF::_internal_add_scenes() {
  return _impl_.scenes_.Add();
}
inline ::mc::comm::Scene* GLTF::add_scenes() {
  ::mc::comm::Scene* _add = _internal_add_scenes();
  // @@protoc_insertion_point(field_add:mc.comm.GLTF.scenes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Scene >&
GLTF::scenes() const {
  // @@protoc_insertion_point(field_list:mc.comm.GLTF.scenes)
  return _impl_.scenes_;
}

// repeated .mc.comm.Node nodes = 3;
inline int GLTF::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int GLTF::nodes_size() const {
  return _internal_nodes_size();
}
inline void GLTF::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::mc::comm::Node* GLTF::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:mc.comm.GLTF.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Node >*
GLTF::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:mc.comm.GLTF.nodes)
  return &_impl_.nodes_;
}
inline const ::mc::comm::Node& GLTF::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::mc::comm::Node& GLTF::nodes(int index) const {
  // @@protoc_insertion_point(field_get:mc.comm.GLTF.nodes)
  return _internal_nodes(index);
}
inline ::mc::comm::Node* GLTF::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::mc::comm::Node* GLTF::add_nodes() {
  ::mc::comm::Node* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:mc.comm.GLTF.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Node >&
GLTF::nodes() const {
  // @@protoc_insertion_point(field_list:mc.comm.GLTF.nodes)
  return _impl_.nodes_;
}

// repeated .mc.comm.Mesh meshes = 4;
inline int GLTF::_internal_meshes_size() const {
  return _impl_.meshes_.size();
}
inline int GLTF::meshes_size() const {
  return _internal_meshes_size();
}
inline void GLTF::clear_meshes() {
  _impl_.meshes_.Clear();
}
inline ::mc::comm::Mesh* GLTF::mutable_meshes(int index) {
  // @@protoc_insertion_point(field_mutable:mc.comm.GLTF.meshes)
  return _impl_.meshes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Mesh >*
GLTF::mutable_meshes() {
  // @@protoc_insertion_point(field_mutable_list:mc.comm.GLTF.meshes)
  return &_impl_.meshes_;
}
inline const ::mc::comm::Mesh& GLTF::_internal_meshes(int index) const {
  return _impl_.meshes_.Get(index);
}
inline const ::mc::comm::Mesh& GLTF::meshes(int index) const {
  // @@protoc_insertion_point(field_get:mc.comm.GLTF.meshes)
  return _internal_meshes(index);
}
inline ::mc::comm::Mesh* GLTF::_internal_add_meshes() {
  return _impl_.meshes_.Add();
}
inline ::mc::comm::Mesh* GLTF::add_meshes() {
  ::mc::comm::Mesh* _add = _internal_add_meshes();
  // @@protoc_insertion_point(field_add:mc.comm.GLTF.meshes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Mesh >&
GLTF::meshes() const {
  // @@protoc_insertion_point(field_list:mc.comm.GLTF.meshes)
  return _impl_.meshes_;
}

// repeated .mc.comm.Texture textures = 5;
inline int GLTF::_internal_textures_size() const {
  return _impl_.textures_.size();
}
inline int GLTF::textures_size() const {
  return _internal_textures_size();
}
inline void GLTF::clear_textures() {
  _impl_.textures_.Clear();
}
inline ::mc::comm::Texture* GLTF::mutable_textures(int index) {
  // @@protoc_insertion_point(field_mutable:mc.comm.GLTF.textures)
  return _impl_.textures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Texture >*
GLTF::mutable_textures() {
  // @@protoc_insertion_point(field_mutable_list:mc.comm.GLTF.textures)
  return &_impl_.textures_;
}
inline const ::mc::comm::Texture& GLTF::_internal_textures(int index) const {
  return _impl_.textures_.Get(index);
}
inline const ::mc::comm::Texture& GLTF::textures(int index) const {
  // @@protoc_insertion_point(field_get:mc.comm.GLTF.textures)
  return _internal_textures(index);
}
inline ::mc::comm::Texture* GLTF::_internal_add_textures() {
  return _impl_.textures_.Add();
}
inline ::mc::comm::Texture* GLTF::add_textures() {
  ::mc::comm::Texture* _add = _internal_add_textures();
  // @@protoc_insertion_point(field_add:mc.comm.GLTF.textures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Texture >&
GLTF::textures() const {
  // @@protoc_insertion_point(field_list:mc.comm.GLTF.textures)
  return _impl_.textures_;
}

// repeated .mc.comm.Image images = 6;
inline int GLTF::_internal_images_size() const {
  return _impl_.images_.size();
}
inline int GLTF::images_size() const {
  return _internal_images_size();
}
inline void GLTF::clear_images() {
  _impl_.images_.Clear();
}
inline ::mc::comm::Image* GLTF::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:mc.comm.GLTF.images)
  return _impl_.images_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Image >*
GLTF::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:mc.comm.GLTF.images)
  return &_impl_.images_;
}
inline const ::mc::comm::Image& GLTF::_internal_images(int index) const {
  return _impl_.images_.Get(index);
}
inline const ::mc::comm::Image& GLTF::images(int index) const {
  // @@protoc_insertion_point(field_get:mc.comm.GLTF.images)
  return _internal_images(index);
}
inline ::mc::comm::Image* GLTF::_internal_add_images() {
  return _impl_.images_.Add();
}
inline ::mc::comm::Image* GLTF::add_images() {
  ::mc::comm::Image* _add = _internal_add_images();
  // @@protoc_insertion_point(field_add:mc.comm.GLTF.images)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Image >&
GLTF::images() const {
  // @@protoc_insertion_point(field_list:mc.comm.GLTF.images)
  return _impl_.images_;
}

// repeated .mc.comm.Sampler samplers = 7;
inline int GLTF::_internal_samplers_size() const {
  return _impl_.samplers_.size();
}
inline int GLTF::samplers_size() const {
  return _internal_samplers_size();
}
inline void GLTF::clear_samplers() {
  _impl_.samplers_.Clear();
}
inline ::mc::comm::Sampler* GLTF::mutable_samplers(int index) {
  // @@protoc_insertion_point(field_mutable:mc.comm.GLTF.samplers)
  return _impl_.samplers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Sampler >*
GLTF::mutable_samplers() {
  // @@protoc_insertion_point(field_mutable_list:mc.comm.GLTF.samplers)
  return &_impl_.samplers_;
}
inline const ::mc::comm::Sampler& GLTF::_internal_samplers(int index) const {
  return _impl_.samplers_.Get(index);
}
inline const ::mc::comm::Sampler& GLTF::samplers(int index) const {
  // @@protoc_insertion_point(field_get:mc.comm.GLTF.samplers)
  return _internal_samplers(index);
}
inline ::mc::comm::Sampler* GLTF::_internal_add_samplers() {
  return _impl_.samplers_.Add();
}
inline ::mc::comm::Sampler* GLTF::add_samplers() {
  ::mc::comm::Sampler* _add = _internal_add_samplers();
  // @@protoc_insertion_point(field_add:mc.comm.GLTF.samplers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Sampler >&
GLTF::samplers() const {
  // @@protoc_insertion_point(field_list:mc.comm.GLTF.samplers)
  return _impl_.samplers_;
}

// repeated .mc.comm.Buffer buffers = 8;
inline int GLTF::_internal_buffers_size() const {
  return _impl_.buffers_.size();
}
inline int GLTF::buffers_size() const {
  return _internal_buffers_size();
}
inline void GLTF::clear_buffers() {
  _impl_.buffers_.Clear();
}
inline ::mc::comm::Buffer* GLTF::mutable_buffers(int index) {
  // @@protoc_insertion_point(field_mutable:mc.comm.GLTF.buffers)
  return _impl_.buffers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Buffer >*
GLTF::mutable_buffers() {
  // @@protoc_insertion_point(field_mutable_list:mc.comm.GLTF.buffers)
  return &_impl_.buffers_;
}
inline const ::mc::comm::Buffer& GLTF::_internal_buffers(int index) const {
  return _impl_.buffers_.Get(index);
}
inline const ::mc::comm::Buffer& GLTF::buffers(int index) const {
  // @@protoc_insertion_point(field_get:mc.comm.GLTF.buffers)
  return _internal_buffers(index);
}
inline ::mc::comm::Buffer* GLTF::_internal_add_buffers() {
  return _impl_.buffers_.Add();
}
inline ::mc::comm::Buffer* GLTF::add_buffers() {
  ::mc::comm::Buffer* _add = _internal_add_buffers();
  // @@protoc_insertion_point(field_add:mc.comm.GLTF.buffers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Buffer >&
GLTF::buffers() const {
  // @@protoc_insertion_point(field_list:mc.comm.GLTF.buffers)
  return _impl_.buffers_;
}

// repeated .mc.comm.BufferView bufferViews = 9;
inline int GLTF::_internal_bufferviews_size() const {
  return _impl_.bufferviews_.size();
}
inline int GLTF::bufferviews_size() const {
  return _internal_bufferviews_size();
}
inline void GLTF::clear_bufferviews() {
  _impl_.bufferviews_.Clear();
}
inline ::mc::comm::BufferView* GLTF::mutable_bufferviews(int index) {
  // @@protoc_insertion_point(field_mutable:mc.comm.GLTF.bufferViews)
  return _impl_.bufferviews_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::BufferView >*
GLTF::mutable_bufferviews() {
  // @@protoc_insertion_point(field_mutable_list:mc.comm.GLTF.bufferViews)
  return &_impl_.bufferviews_;
}
inline const ::mc::comm::BufferView& GLTF::_internal_bufferviews(int index) const {
  return _impl_.bufferviews_.Get(index);
}
inline const ::mc::comm::BufferView& GLTF::bufferviews(int index) const {
  // @@protoc_insertion_point(field_get:mc.comm.GLTF.bufferViews)
  return _internal_bufferviews(index);
}
inline ::mc::comm::BufferView* GLTF::_internal_add_bufferviews() {
  return _impl_.bufferviews_.Add();
}
inline ::mc::comm::BufferView* GLTF::add_bufferviews() {
  ::mc::comm::BufferView* _add = _internal_add_bufferviews();
  // @@protoc_insertion_point(field_add:mc.comm.GLTF.bufferViews)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::BufferView >&
GLTF::bufferviews() const {
  // @@protoc_insertion_point(field_list:mc.comm.GLTF.bufferViews)
  return _impl_.bufferviews_;
}

// repeated .mc.comm.Accessor accessors = 10;
inline int GLTF::_internal_accessors_size() const {
  return _impl_.accessors_.size();
}
inline int GLTF::accessors_size() const {
  return _internal_accessors_size();
}
inline void GLTF::clear_accessors() {
  _impl_.accessors_.Clear();
}
inline ::mc::comm::Accessor* GLTF::mutable_accessors(int index) {
  // @@protoc_insertion_point(field_mutable:mc.comm.GLTF.accessors)
  return _impl_.accessors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Accessor >*
GLTF::mutable_accessors() {
  // @@protoc_insertion_point(field_mutable_list:mc.comm.GLTF.accessors)
  return &_impl_.accessors_;
}
inline const ::mc::comm::Accessor& GLTF::_internal_accessors(int index) const {
  return _impl_.accessors_.Get(index);
}
inline const ::mc::comm::Accessor& GLTF::accessors(int index) const {
  // @@protoc_insertion_point(field_get:mc.comm.GLTF.accessors)
  return _internal_accessors(index);
}
inline ::mc::comm::Accessor* GLTF::_internal_add_accessors() {
  return _impl_.accessors_.Add();
}
inline ::mc::comm::Accessor* GLTF::add_accessors() {
  ::mc::comm::Accessor* _add = _internal_add_accessors();
  // @@protoc_insertion_point(field_add:mc.comm.GLTF.accessors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mc::comm::Accessor >&
GLTF::accessors() const {
  // @@protoc_insertion_point(field_list:mc.comm.GLTF.accessors)
  return _impl_.accessors_;
}

// .mc.comm.Asset asset = 11;
inline bool GLTF::_internal_has_asset() const {
  return this != internal_default_instance() && _impl_.asset_ != nullptr;
}
inline bool GLTF::has_asset() const {
  return _internal_has_asset();
}
inline void GLTF::clear_asset() {
  if (GetArenaForAllocation() == nullptr && _impl_.asset_ != nullptr) {
    delete _impl_.asset_;
  }
  _impl_.asset_ = nullptr;
}
inline const ::mc::comm::Asset& GLTF::_internal_asset() const {
  const ::mc::comm::Asset* p = _impl_.asset_;
  return p != nullptr ? *p : reinterpret_cast<const ::mc::comm::Asset&>(
      ::mc::comm::_Asset_default_instance_);
}
inline const ::mc::comm::Asset& GLTF::asset() const {
  // @@protoc_insertion_point(field_get:mc.comm.GLTF.asset)
  return _internal_asset();
}
inline void GLTF::unsafe_arena_set_allocated_asset(
    ::mc::comm::Asset* asset) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.asset_);
  }
  _impl_.asset_ = asset;
  if (asset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mc.comm.GLTF.asset)
}
inline ::mc::comm::Asset* GLTF::release_asset() {
  
  ::mc::comm::Asset* temp = _impl_.asset_;
  _impl_.asset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mc::comm::Asset* GLTF::unsafe_arena_release_asset() {
  // @@protoc_insertion_point(field_release:mc.comm.GLTF.asset)
  
  ::mc::comm::Asset* temp = _impl_.asset_;
  _impl_.asset_ = nullptr;
  return temp;
}
inline ::mc::comm::Asset* GLTF::_internal_mutable_asset() {
  
  if (_impl_.asset_ == nullptr) {
    auto* p = CreateMaybeMessage<::mc::comm::Asset>(GetArenaForAllocation());
    _impl_.asset_ = p;
  }
  return _impl_.asset_;
}
inline ::mc::comm::Asset* GLTF::mutable_asset() {
  ::mc::comm::Asset* _msg = _internal_mutable_asset();
  // @@protoc_insertion_point(field_mutable:mc.comm.GLTF.asset)
  return _msg;
}
inline void GLTF::set_allocated_asset(::mc::comm::Asset* asset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.asset_;
  }
  if (asset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(asset);
    if (message_arena != submessage_arena) {
      asset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, asset, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.asset_ = asset;
  // @@protoc_insertion_point(field_set_allocated:mc.comm.GLTF.asset)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace comm
}  // namespace mc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mc_2fcomm_2fgltf_2eproto
